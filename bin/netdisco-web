#!/usr/bin/env perl

use strict;
use warnings;

# 声明全局变量 $home 用于存储 Netdisco 主目录
our $home;

BEGIN {
  use FindBin;
  FindBin::again();

  # 获取当前脚本的完整路径和用户ID
  my $me = File::Spec->catfile($FindBin::RealBin, $FindBin::RealScript);
  my $uid = (stat($me))[4] || 0;

  # 设置 Netdisco 主目录，优先级：NETDISCO_HOME > 用户主目录 > HOME
  $home = ($ENV{NETDISCO_HOME} || (getpwuid($uid))[7] || $ENV{HOME});

  # 尝试查找 localenv 脚本，如果不存在 PERL_LOCAL_LIB_ROOT 环境变量
  if (!exists $ENV{PERL_LOCAL_LIB_ROOT}) {
      use File::Spec;
      # 首先在 bin 目录中查找 localenv
      my $localenv = File::Spec->catfile($FindBin::Bin, 'localenv');
      exec($localenv, $0, @ARGV) if -f $localenv;
      # 然后在用户目录中查找 localenv
      $localenv = File::Spec->catfile($home, 'perl5', 'bin', 'localenv');
      exec($localenv, $0, @ARGV) if -f $localenv;

      # 如果找不到 localenv 且没有 PERLBREW_PERL 环境变量，则退出
      die "Sorry, can't find libs required for App::Netdisco.\n"
        if !exists $ENV{PERLBREW_PERL};
  }
}

BEGIN {
  use Path::Class;

  # 将有用的库路径添加到 @INC 和 $PATH 中
  unshift @INC,
    dir($FindBin::RealBin)->parent->subdir('lib')->stringify,
    dir($FindBin::RealBin, 'lib')->stringify;

  # 将 bin 目录添加到 PATH 环境变量中
  use Config;
  $ENV{PATH} = $FindBin::RealBin . $Config{path_sep} . $ENV{PATH};
}

use Daemon::Control;
use Filesys::Notify::Simple;
use IO::File;
use File::Copy;

use Getopt::Long;
Getopt::Long::Configure ("pass_through");

my ($logfiles, $logsize) = (8,10);
my $result = GetOptions(
  'logfiles=i' => \$logfiles,
  'logsize=i'  => \$logsize,
);

use App::Netdisco::Environment;
my $config = ($ENV{PLACK_ENV} || $ENV{DANCER_ENVIRONMENT}) .'.yml';

# 确保配置文件存在
my $template_config = file($ENV{DANCER_CONFDIR}, 'environments', $config);
my $app_config = file($ENV{DANCER_ENVDIR}, $config);
if (! -e $app_config and -e $template_config) {
  copy $template_config, $app_config;
}
if (! -e $app_config) {
  die "error: cannot find Netdisco config at $template_config or $app_config\n";
}

my $netdisco = file($FindBin::RealBin, 'netdisco-web-fg');
my @args = (scalar @ARGV > 1 ? @ARGV[1 .. $#ARGV] : ());

if (exists $ENV{PORT} and 0 == scalar grep { $_ =~ m/port/ } @args) {
    push @args, "--port=$ENV{PORT}";
}

my $uid = (stat($netdisco->stringify))[4] || 0;
my $gid = (stat($netdisco->stringify))[5] || 0;

my $log_dir = dir($home, 'logs');
mkdir $log_dir if ! -d $log_dir;
chown $uid, $gid, $log_dir;

my $pid_file = file($home, 'netdisco-web.pid');
my $log_file = file($log_dir, 'netdisco-web.log');

# 更改关键文件的所有者为 netdisco 用户
foreach my $file ($pid_file, $log_file) {
    unless (-e $file) {
        sysopen my $fh, $file, O_WRONLY|O_CREAT|O_NONBLOCK|O_NOCTTY;
        print $fh '0' if $file eq $pid_file;
        close $fh;
    }
    chown $uid, $gid, $file;
}

# 清理旧的 Web 会话
my $sdir = dir($home, 'netdisco-web-sessions')->stringify;
unlink glob file($sdir, '*');

Daemon::Control->new({
  name => 'Netdisco Web',
  program  => \&restarter,
  program_args => [
    '--disable-keepalive',
    '--user', $uid, '--group', $gid,
    @args, $netdisco->stringify
  ],
  pid_file => $pid_file,
  stderr_file => $log_file,
  stdout_file => $log_file,
  redirect_before_fork => 0,
  ((scalar grep { $_ =~ m/port/ } @args) ? ()
                                         : (uid => $uid, gid => $gid)),
})->run;

# 此部分的核心逻辑借鉴自 Plack::Loader::Restarter - 非常感谢！！

# Web 服务器重启器
# 用途：监控配置文件变化，自动重启 Web 服务器进程，处理日志轮转
sub restarter {
  my ($daemon, @program_args) = @_;

  # 启动子进程
  my $child = fork_and_start($daemon, @program_args);
  exit(1) unless $child;

  # 创建文件系统监控器，监控配置目录和日志目录
  my $watcher = Filesys::Notify::Simple->new([$ENV{DANCER_ENVDIR}, $log_dir]);
  warn "config watcher: watching $ENV{DANCER_ENVDIR} for updates.\n";

  # TODO: starman 还支持 TTIN,TTOU,INT,QUIT 信号
  local $SIG{HUP}  = sub { signal_child('HUP',  $child); };
  local $SIG{TERM} = sub { signal_child('TERM', $child); exit(0); };

  # 主监控循环
  while (1) {
      my @restart;

      # 这是阻塞调用，等待文件变化事件
      $watcher->wait(sub {
          my @events = @_;
          # 只关注日志文件或配置文件的变化
          @events = grep {$_->{path} eq $log_file or
                          file($_->{path})->basename eq $config} @events;
          return unless @events;
          @restart = @events;
      });

      my ($hupit, $rotate) = (0, 0);
      next unless @restart;

      # 处理文件变化事件
      foreach my $f (@restart) {
          if ($f->{path} eq $log_file) {
              ++$rotate;  # 日志文件变化，需要轮转日志
          }
          else {
              warn "-- $f->{path} updated.\n";
              ++$hupit;   # 配置文件变化，需要重启进程
          }
      }

      # 根据事件类型执行相应操作
      rotate_logs($child) if $rotate;
      if ($hupit) {
          signal_child('TERM', $child);
          warn "successfully terminated! Restarting the web server process.\n";
          $child = fork_and_start($daemon, @program_args);
          return unless $child;
      }
  }
}

# 创建子进程并启动 Starman Web 服务器
# 用途：fork 子进程并执行 Starman Web 服务器
sub fork_and_start {
  my ($daemon, @starman_args) = @_;
  my $pid = fork;
  die "Can't fork: $!" unless defined $pid;

  if ($pid == 0) { # 子进程
      $daemon->redirect_filehandles;
      exec( 'starman', @starman_args );
  }
  else {
      return $pid;
  }
}

# 向子进程发送信号
# 用途：向 Web 服务器子进程发送信号并等待其结束
sub signal_child {
  my ($signal, $pid) = @_;
  return unless $signal and $pid;
  warn "config watcher: sending $signal to the web server (pid:$pid)...\n";
  kill $signal => $pid;
  waitpid($pid, 0);
}

# 轮转日志文件
# 用途：当日志文件超过指定大小时，进行日志轮转，避免日志文件过大
sub rotate_logs {
  my $child = shift;

  # 检查日志文件是否存在且超过指定大小
  return unless (-f $log_file) and
    ((-s $log_file) > ($logsize * 1024768));

  # 获取所有现有的日志轮转文件
  my @files = grep { /$log_file\.\d+/ } glob file($log_dir, '*');
  # 按文件名倒序排列，处理日志轮转
  foreach my $f (sort { $b cmp $a } @files) {
      next unless $f =~ m/$log_file\.(\d+)$/;
      my $pos = $1;
      # 删除最旧的日志文件
      unlink $f if $pos == ($logfiles - 1);
      my $next = $pos + 1;
      (my $newf = $f) =~ s/\.$pos$/.$next/;
      rename $f, $newf;
  }

  # 如果日志文件大约 10M，则复制/截断过程中的竞争条件
  # 数据丢失的风险较低。如果文件更大，则重命名并
  # 终止进程。
  if ((-s $log_file) > (12 * 1024768)) {
      rename $log_file, $log_file .'.1';
      signal_child('HUP', $child);
  }
  else {
      copy $log_file, $log_file .'.1';
      truncate $log_file, 0;
  }
}

=head1 NAME

netdisco-web - Web Application Server for Netdisco

=head1 SEE ALSO

=over 4

=item *

L<App::Netdisco>

=back

=cut
