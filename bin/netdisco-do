#!/usr/bin/env perl

use strict;
use warnings;

# 声明全局变量 $home 用于存储 Netdisco 主目录
our $home;

BEGIN {
  use FindBin;
  FindBin::again();

  # 设置 Netdisco 主目录，优先使用环境变量 NETDISCO_HOME，否则使用 HOME
  $home = ($ENV{NETDISCO_HOME} || $ENV{HOME});

  # 尝试查找 localenv 脚本，如果不存在 PERL_LOCAL_LIB_ROOT 环境变量
  if (!exists $ENV{PERL_LOCAL_LIB_ROOT}) {
      use File::Spec;
      # 首先在脚本目录中查找 localenv
      my $localenv = File::Spec->catfile($FindBin::RealBin, 'localenv');
      exec($localenv, $0, @ARGV) if -f $localenv;
      # 然后在用户目录中查找 localenv
      $localenv = File::Spec->catfile($home, 'perl5', 'bin', 'localenv');
      exec($localenv, $0, @ARGV) if -f $localenv;

      # 如果找不到 localenv 且没有 PERLBREW_PERL 环境变量，则退出
      die "Sorry, can't find libs required for App::Netdisco.\n"
        if !exists $ENV{PERLBREW_PERL};
  }
}

BEGIN {
  use Path::Class;

  # 将有用的库路径添加到 @INC 中
  unshift @INC,
    dir($FindBin::RealBin)->parent->subdir('lib')->stringify,
    dir($FindBin::RealBin, 'lib')->stringify;
}

# 导入 Netdisco 应用和 Dancer 框架
use App::Netdisco;
use Dancer qw/:moose :script/;

# 导入异常处理、文档使用、对象检查和文件处理模块
use Try::Tiny;
use Pod::Usage;
use Scalar::Util 'blessed';
use File::Slurper qw/read_lines read_text/;
use NetAddr::IP qw/:rfc3021 :lower/;

# 导入 Netdisco 后端作业、作业队列和设备工具模块
use App::Netdisco::Backend::Job;
use App::Netdisco::JobQueue 'jq_insert';
use App::Netdisco::Util::Device 'get_device';

# 配置命令行参数解析
use Getopt::Long;
Getopt::Long::Configure ("bundling");

# 声明命令行参数变量
my ($port, $extra, $debug, $quiet, $queue_only, $force, $dryrun, $rollback);
my ($devices, $infotrace, $snmptrace, $sqltrace) = ([], 0, 0, 0);

# 解析命令行参数
my $result = GetOptions(
  'device|d=s@' => \$devices,      # 设备列表
  'port|p=s'   => \$port,          # 端口
  'extra|e=s'  => \$extra,         # 额外参数
  'debug|D'    => \$debug,         # 调试模式
  'enqueue'    => \$queue_only,    # 仅入队
  'force'      => \$force,         # 强制模式
  'dry-run'    => \$dryrun,        # 试运行
  'quiet'      => \$quiet,         # 静默模式
  'rollback|R' => \$rollback,      # 回滚模式
  'infotrace|I+' => \$infotrace,   # 信息跟踪
  'snmptrace|S+' => \$snmptrace,   # SNMP 跟踪
  'sqltrace|Q+'  => \$sqltrace,   # SQL 跟踪
) or pod2usage(
  -msg => 'error: bad options',
  -verbose => 0,
  -exitval => 1,
);

# 如果是试运行模式，设置环境变量并启用调试
if ($dryrun) {
  $ENV{ND2_WORKER_ROLL_CALL} = 1;
  $debug = 1;
}

my $CONFIG = config();
$CONFIG->{logger} = 'console';
$CONFIG->{log} = ($debug ? 'debug' : ($quiet ? 'error' : 'info'));

$ENV{INFO_TRACE} ||= $infotrace;
$ENV{SNMP_TRACE} ||= $snmptrace;
$ENV{DBIC_TRACE} ||= $sqltrace;
$ENV{ND2_DO_FORCE} ||= $force;
$ENV{ND2_DO_QUIET} ||= $quiet;
$ENV{ND2_DB_ROLLBACK} ||= $rollback;

# 重新配置日志记录以强制控制台输出
Dancer::Logger->init('console', $CONFIG);

info "App::Netdisco version $App::Netdisco::VERSION loaded.";

# 获取请求的操作
(my $action = shift @ARGV) =~ s/^set_//
  if scalar @ARGV;

unless ($action) {
    pod2usage(
      -msg => 'error: missing action!',
      -verbose => 2,
      -exitval => 2,
    );
}

# 创建工作进程（操作运行器的占位符对象）
{
  package MyWorker;
  use Moo;
  with 'App::Netdisco::Worker::Runner';
}

# 从 -d 参数解析的 NetAddr::IP 实例列表
my @hostlist = ();

# 测试和解析设备地址
# 用途：验证设备地址格式，解析 IP 地址或网络前缀，生成主机列表
sub _test_and_resolve_device {
  my $d = shift or return;
  # 去除空白字符
  $d =~ s/\s//g;
  return unless $d;

  # 尝试解析为网络地址对象
  my $net = NetAddr::IP->new($d);
  if (!$net or $net->num == 0 or $net->addr eq '0.0.0.0') {
      error sprintf 'unable to understand as host, IP, or prefix: %s', $d;
      exit 1;
  }

  # 将解析后的主机地址添加到主机列表
  push @hostlist, $net->hostenum;
  return;
}

# 处理设备参数列表
# 用途：解析设备参数，支持直接设备地址、文件列表或网络前缀
foreach my $device (@$devices) {
  # 如果操作目标是网络前缀，直接添加到主机列表
  if (scalar grep {$action eq $_} @{ setting('job_targets_prefix') }) {
      push @hostlist, $device;
  }
  # 如果设备参数是文件，读取文件内容
  elsif (-f $device) {
      debug sprintf 'opening file for reading hosts/IPs: %s', $device;
      my @dlist = read_lines $device;

      if (0 == scalar @dlist) {
          error sprintf 'unable to read from file: %s', $device;
          exit 2;
      }

      # 处理文件中的每一行
      foreach my $entry (@dlist) {
          _test_and_resolve_device($entry);
      }
  }
  # 否则直接处理设备地址
  else {
      _test_and_resolve_device($device);
  }
}

# 初始化作业规格列表和退出状态
my @job_specs = ();
my $exitstatus =  0;

# 检查作业数量限制（除非使用 --force 参数）
if (not $force and scalar @hostlist > 512) {
    info sprintf '%s: aborted - unwise to attempt %s jobs at once', $action, (scalar @hostlist);
    exit 1;
}

# 处理需要额外数据的操作（自定义字段、MAC 收集、ARP 收集）
if ($action =~ m/^(?:cf_|macsuck|arpnip)/ and $extra) {
    # 从标准输入读取数据
    if ($extra eq '@-' or ($quiet and $extra eq '-')) {
        $extra = do { local $/; <STDIN> };
    }
    # 从文件读取数据
    elsif ($extra =~ m/^@(.+)/) {
        my $filename = $1;
        if (-f $filename) {
            $extra = read_text($filename);
        }
        else {
            error sprintf 'unable to read from file: %s', $filename;
            exit 2;
        }
    }
}

# 某些操作不需要设备参数
@hostlist = (undef) if 0 == scalar @hostlist;

# 为每个主机创建作业规格
foreach my $host (@hostlist) {
  push @job_specs, {
    action => $action,
    device => ref $host ? $host->addr : $host,
    port   => $port,
    subaction => $extra,
    username => ($ENV{USER} || 'netdisco-do'),
  };
}

# 根据是否仅入队执行不同逻辑
if ($queue_only) {
  # 仅将作业加入队列
  jq_insert( \@job_specs );
  info sprintf '%s: queued %s jobs at %s',
    $action, (scalar @job_specs), scalar localtime;
}
else {
  # 立即执行作业
  foreach my $spec (@job_specs) {
    my $worker = MyWorker->new();
    my $job = App::Netdisco::Backend::Job->new({ job => 0, %$spec });
    
    # 为特定操作设置最小年龄为 0
    $CONFIG->{$1."_min_age"} = 0 if $job->action =~ m/^(arpnip|macsuck|discover)$/;
    # 如果使用强制模式，忽略所有层组
    $CONFIG->{ignore_layers} = 'group:__ANY__' if $force;

    # 构建操作文本显示
    my $actiontext = (
      ($job->device ? ('['.$job->device.']') : '') .
      ($job->action eq 'show' ? ('/'. ($job->subaction || 'interfaces')) : '')
    );

    # 执行作业
    try {
      info sprintf '%s: %s started at %s',
        $action, $actiontext, scalar localtime;
      $worker->run($job);
    }
    catch {
      $job->status('error');
      $job->log("error running job: $_");
    };

    # 检查作业是否有效
    if ($job->log eq 'failed to report from any worker!' and not $job->only_namespace) {
      pod2usage(
        -msg => (sprintf 'error: %s is not a valid action (no worker status recorded)', $action),
        -verbose => 2,
        -exitval => 3,
      );
    }

    # 记录作业完成状态
    info sprintf '%s: finished at %s', $action, scalar localtime;
    info sprintf '%s: status %s: %s', $action, $job->status, $job->log;
    $exitstatus = 1 if !$exitstatus and $job->status ne 'done';
  }
}

exit $exitstatus;

=encoding UTF-8

=head1 NAME

netdisco-do - Run any Netdisco job from the command-line.

=head1 SYNOPSIS

 ~/bin/netdisco-do <action> [-DISQR] [--enqueue] [--force] [--quiet] [-d <device> [-p <port>] [-e <extra>]]

=head1 DESCRIPTION

This program allows you to run any Netdisco poller job from the command-line.

=head1 ACTIONS

Note that some jobs (C<discoverall>, C<macwalk>, C<arpwalk>, C<nbtwalk>)
simply add entries to the Netdisco job queue for other jobs, so won't seem
to do much when you trigger them. Everything else happens in real-time.

However the "C<--enqueue>" option will force the queueing of the job,
regardless of type. This may be useful for cron-driven actions, or for actions
working across large IP spaces. Netdisco will refuse to queue more than 512
jobs at once unless you also add the "C<--force>" option.

For any action, if you wish to run one of its individual worker stages, then
pass C<action::stage> as the first argument to C<netdisco-do>, for example
C<discover::neighbors>.

Any action taking a C<device> parameter can be passed either a hostname or IP
address of any interface of a known or unknown device, or an IP prefix
(subnet) which will cause C<netdisco-do> to run the action on all addresses in
that range. The C<device> parameter may also be a filename that Netdisco will
open to read hostnames, IPs, or prefixes, one per line.

The C<device> parameter may be passed multiple times. In this case, all
addresses (after expanding IP Prefixes) will be handled one by one.

=head2 discover

Run a discover on the device (specified with C<-d>).

 ~/bin/netdisco-do discover -d 192.0.2.1

Run a discover on two different devices (specified with C<-d>).

 ~/bin/netdisco-do discover -d 192.0.2.1 -d 192.15.2.95

=head2 discoverall

Queue a discover for all known devices.

=head2 pingsweep

Scan an IP prefix (subnet) using ping utility (must be installed), any
host responding has a C<discover> job queued. It is recommended to queue
the C<pingsweep> job as well.

 ~/bin/netdisco-do pingsweep -d 192.0.2.0/24 --enqueue

The default ping timeout is 0.1 seconds. To change this, pass any number
to the C<-e> parameter.

=head2 macsuck

Run a macsuck on the device (specified with C<-d>).

 ~/bin/netdisco-do macsuck -d 192.0.2.1

Submit macsuck data directly to Netdisco in JSON format (see API web
docs for data format example):

 # pipe to standard input
 ~/bin/netdisco-do macsuck -d 192.0.2.1 -e '@-'
 # read from a file
 ~/bin/netdisco-do macsuck -d 192.0.2.1 -e '@/tmp/mac-address-table.json'
 # pass directly
 ~/bin/netdisco-do macsuck -d 192.0.2.1 -e '[{"ip": "string", "mac": "string", "dns": "string"}]'

=head2 macwalk

Queue a macsuck for all known devices.

=head2 arpnip

Run an arpnip on the device (specified with C<-d>).

 ~/bin/netdisco-do arpnip -d 192.0.2.1

Submit arpnip data directly to Netdisco in JSON format (see API web
docs for data format example):

 # pipe to standard input
 ~/bin/netdisco-do arpnip -d 192.0.2.1 -e '@-'
 # read from a file
 ~/bin/netdisco-do arpnip -d 192.0.2.1 -e '@/tmp/mac-address-table.json'
 # pass directly
 ~/bin/netdisco-do arpnip -d 192.0.2.1 -e '[{"ip": "string", "mac": "string", "dns": "string"}]'

=head2 arpwalk

Queue an arpnip for all known devices.

=head2 delete

Delete a device (specified with C<-d>). Pass a log message for the action in
the C<-e> parameter. Optionally request for associated nodes to be archived
(rather than deleted) by setting the C<-p> parameter to "C<yes>" (mnemonic:
B<p>reserve).

 ~/bin/netdisco-do delete -d 192.0.2.1
 ~/bin/netdisco-do delete -d 192.0.2.1 -e 'older than the sun'
 ~/bin/netdisco-do delete -d 192.0.2.1 -e 'older than the sun' -p yes

=head2 renumber

Change the canonical IP address of a device (specified with C<-d>). Pass the
new IP address in the C<-e> parameter. All related records such as topology,
log and node information will also be updated to refer to the new device.

Note that I<no> check is made as to whether the new IP is reachable for future
polling.

 ~/bin/netdisco-do renumber -d 192.0.2.1 -e 192.0.2.254

=head2 nbtstat

Run an nbtstat on the node (specified with C<-d>).

 ~/bin/netdisco-do nbtstat -d 192.0.2.2

=head2 nbtwalk

Queue an nbtstat for all known nodes.

=head2 Custom Field update

Update a Device or Device Port custom field using `netdisco-do`. Specify
the field name as the "action" prefixed with `cf_`. The content can be
passed in the command, or taken from a file, or from standard input.

 # pass directly
 ~/bin/netdisco-do cf_myfield --enqueue -d 192.0.2.1 -e 'field value'
 # pipe from standard input
 ~/bin/netdisco-do cf_myfield --enqueue -d 192.0.2.1 -e '@-'
 # read from a file
 ~/bin/netdisco-do cf_myfield --enqueue -d 192.0.2.1 -e '@/tmp/myfield'

Note that `--enqueue ` is *required* for the feature to work. The change
is, however, applied instanty in the database when `netdisco-do` runs.

=head2 expire

Run Device and Node expiry actions according to configuration.

=head2 expirenodes

Archive nodes on the specified device. If you want to delete nodes, set the
C<-e> parameter to "C<no>" (mnemonic: B<e>xpire). If you want to perform the
action on a specific port, set the C<-p> parameter.

 ~/bin/netdisco-do expirenodes -d 192.0.2.1
 ~/bin/netdisco-do expirenodes -d 192.0.2.1 -p FastEthernet0/1 -e no

=head2 graph

Generate GraphViz graphs for the largest cluster of devices.

You'll need to install the L<Graph::Undirected> and L<GraphViz> Perl modules,
and possibly also the C<graphviz> utility for your operating system. Also
create a directory for the output files.

 mkdir ~/graph
 ~/bin/localenv cpanm Graph::Undirected
 ~/bin/localenv cpanm GraphViz

=head2 show

Dump the content of an SNMP MIB Object or an L<SNMP::Info> method, useful for
diagnostics and troubleshooting.

You should provide the "C<-e>" option which is the name of the method or
object, such as C<interfaces> or C<uptime> or C<ifDescr>.

If you wish to specify the SNMP MIB to load and find the Object in, then
you can qualify the "C<-e>" parameter, such as C<IF-MIB::ifDescr>.

If you wish to test with a specific L<SNMP::Info> device class other than the
one discovered, pass this in the "C<-p>" parameter, such as C<Layer3> or
C<SNMP::Info::Layer3> (the C<SNMP::Info> prefix is optional).

All "C<-e>" parameters are case sensitive.

 ~/bin/netdisco-do show -d 192.0.2.1 -e interfaces
 ~/bin/netdisco-do show -d 192.0.2.1 -e IF-MIB::ifDescr
 ~/bin/netdisco-do show -d 192.0.2.1 -e interfaces -p SNMP::Info::Layer2::HP
 ~/bin/netdisco-do show -d 192.0.2.1 -e ifName -p Layer3::Arista

The "C<-e>" parameter C<specify> will show the used configuration for the
specified device.

 ~/bin/netdisco-do show -d 192.0.2.1 -e specify

Passing the "C< --quiet >" command line flag will cause C<show> to return
data in a compact JSON format (suitable for piping to C<jq>, for example).

If the output is very long, you may see a "skipping..." message. Work
around this by passing "C< --quiet >" and then pipe the output to
"C<jq .>".

This command works well with the "C<-I>" debug flag on L<SNMP::Info> (or
"C<-II>").

=head2 psql

Start an interactive terminal with the Netdisco PostgreSQL database. If you
pass an SQL statement in the C<-e> option then it will be executed.

 ~/bin/netdisco-do psql
 ~/bin/netdisco-do psql -e 'SELECT ip, dns FROM device'
 ~/bin/netdisco-do psql -e 'COPY (SELECT ip, dns FROM device) TO STDOUT WITH CSV HEADER'

=head2 stats

Updates Netdisco's statistics on number of devices, nodes, etc, for today.

=head2 location

Set the SNMP location field on the device (specified with C<-d>). Pass the
location string in the C<-e> extra parameter. Use C<--force> to bypass
user access controls.

 ~/bin/netdisco-do location -d 192.0.2.1 -e 'wiring closet'

=head2 contact

Set the SNMP contact field on the device (specified with C<-d>). Pass the
contact name in the C<-e> extra parameter. Use C<--force> to bypass
user access controls.

 ~/bin/netdisco-do contact -d 192.0.2.1 -e 'tel: 555-2453'

=head2 portname

Set the description on a device port. Requires the C<-d> parameter (device),
C<-p> parameter (port), and C<-e> parameter (description). Use C<--force> to
bypass user access controls.

 ~/bin/netdisco-do portname -d 192.0.2.1 -p FastEthernet0/1 -e 'Web Server'

=head2 portcontrol

Set the up/down status on a device port. Requires the C<-d> parameter
(device), C<-p> parameter (port), and C<-e> parameter ("up" or "down").
Use C<--force> to bypass user access controls.

 ~/bin/netdisco-do portcontrol -d 192.0.2.1 -p FastEthernet0/1 -e up
 ~/bin/netdisco-do portcontrol -d 192.0.2.1 -p FastEthernet0/1 -e down

=head2 vlan

Set the native VLAN on a device port. Requires the C<-d> parameter (device),
C<-p> parameter (port), and C<-e> parameter (VLAN number). Use C<--force> to
bypass user access controls.

 ~/bin/netdisco-do vlan -d 192.0.2.1 -p FastEthernet0/1 -e 102

=head2 power

Set the PoE on/off status on a device port. Requires the C<-d> parameter
(device), C<-p> parameter (port), and C<-e> parameter ("on" or "off").
Use C<--force> to bypass user access controls.

 ~/bin/netdisco-do power -d 192.0.2.1 -p FastEthernet0/1 -e on
 ~/bin/netdisco-do power -d 192.0.2.1 -p FastEthernet0/1 -e off

=head2 makerancidconf

Generates rancid configuration for known devices. See
L<App::Netdisco::Worker::Plugin::MakeRancidConf> for configuration needs.

 ~/bin/netdisco-do makerancidconf

=head2 getapikey

Generates an API key for the supplied username. See the 
L<API doc|https://github.com/netdisco/netdisco/wiki/API> for further 
information.

 ~/bin/netdisco-do getapikey -e the_username 

=head2 dumpconfig

Will dump the loaded and parsed configuration for the application. Pass a
specific configuration setting name to the C<-e> parameter to dump only that.

Some configuration items like device_auth are evaluated against the ACL first.
Pass a device in C<-d> to display them:

 ~/bin/netdisco-do dumpconfig -d 192.0.2.1 -e device_auth

=head2 loadmibs

A requirement for web browsing of SNMP data (see C<snapshot> command), run
this to load Netdisco MIBs into the database. It only needs to be done once.

=head2 snapshot

Builds and saves a data structure which Netdisco can use to mimic the device
(if shared) and also browse the SNMP Objects in the web.

By default the command will gather Objects which can be downloaded from the
web under Device Details tab. This allows another user to mimic your device.

If you previously ran the C<loadmibs> action before running this action,
the Objects also become browsable in the web (under Device SNMP tab).

Normally the SNMP Objects are all gathered from C<.1> root but you can use
C<-e> parameter to change this.

=head2 addpseudodevice

Adds a Pseudo Device which can be used to connect together unconnected parts
of your network or to gather ARP via CLI/API when SNMP is not available.

Pass the Pseudo Device IP in the L<-d> parameter. Pass the Pseudo Device name
in the L<-e> parameter. Pass the number of ports (one or more) in the L<-p>
parameter. All parameters are required. For example:

 ~/bin/netdisco-do addpseudodevice -d 192.0.2.1 -e fakerouter -p 10

=head1 DEBUG OPTIONS

The flag "C<-R>" will cause any changes to the database to be rolled back
at the end of the action.

The flags "C<-DISQ>" can be specified, multiple times, and enable the
following items in order:

=over 4

=item C<-D>

Netdisco debug log level.

=item C<-I> or C<-II>

L<SNMP::Info> trace level (1 or 2).

=item C<-S> or C<-SS> or C<-SSS>

L<SNMP> (net-snmp) trace level (1, 2 or 3).

=item C<-Q>

L<DBIx::Class> trace enabled.

=back

In case of issues with the colored output, setting the environment variable
C<ANSI_COLORS_DISABLED> or C<NO_COLOR> can be used to suppress it.

The C<< --dry-run >> option can be provided to show the workers that will run
without actually executing their content. Setting the C<ND2_WORKER_ROLL_CALL>
environment variable does the same thing.

=cut
