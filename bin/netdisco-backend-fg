#!/usr/bin/env perl

use strict;
use warnings;

# 使用 FindBin 模块来定位脚本所在目录
use FindBin;
FindBin::again();
use Path::Class 'dir';

BEGIN {
  # 将有用的库路径添加到 @INC 中
  unshift @INC,
    dir($FindBin::RealBin)->parent->subdir('lib')->stringify,
    dir($FindBin::RealBin, 'lib')->stringify;

  # 添加额外的库路径（从环境变量 NETDISCO_INC 获取）
  unshift @INC,
    split m/:/, ($ENV{NETDISCO_INC} || '');
}

# 导入 Netdisco 应用和 Dancer 框架
use App::Netdisco;
use Dancer qw/:moose :script/;

BEGIN {
  # 显示 Netdisco 版本信息
  warning sprintf "App::Netdisco %s backend", ($App::Netdisco::VERSION || 'HEAD');

  # 解析后端主机名（这可能需要几秒钟，所以只执行一次）
  use Net::Domain 'hostfqdn';
  info 'resolving backend hostname...';
  setting('workers')->{'BACKEND'} ||= (hostfqdn || 'fqdn-undefined');
}

# 导入 MCE 工具模块（设置 $0 并解析最大工作进程数）
use App::Netdisco::Util::MCE;
# 导入网络地址处理模块（用于抑制 AF_INET6 符号错误）
use NetAddr::IP::Lite ':lower';
use Role::Tiny::With;

# 配置 MCE 多进程处理
use MCE::Signal '-setpgrp';
use MCE::Flow Sereal => 1;
use MCE::Queue porder => $MCE::Queue::HIGHEST,
               type   => $MCE::Queue::FIFO;

# 设置 MCE 临时文件的主目录位置
my $home = ($ENV{NETDISCO_HOME} || $ENV{HOME});
my $tmp_dir = ($ENV{NETDISCO_TEMP} || dir($home, 'tmp'));
mkdir $tmp_dir if ! -d $tmp_dir;

# 设置进程表文本
prctl 'nd2: master';

# 创建共享的本地作业队列
my $queue = MCE::Queue->new;

# 支持仅调度器节点（不运行管理器）
setting('workers')->{'no_manager'} = 1
  if setting('workers')->{tasks} eq '0';

# MCE::Util 在 max_workers 中使用 AUTO 时有 ncpu 限制，
# 所以我们自己解析这个字段
my $max_workers = parse_max_workers( setting('workers')->{tasks} ) || 0;

# 启动 MCE 流程，创建三种类型的工作进程
mce_flow {
  task_name => [qw/ scheduler manager poller /],
  max_workers => [ 1, 1, $max_workers ],
  tmp_dir => $tmp_dir,
  on_post_exit => sub { MCE->restart_worker },
}, _mk_wkr('Scheduler'), _mk_wkr('Manager'), _mk_wkr('Poller');

# 创建工作进程的工厂函数
sub _mk_wkr {
  my $role = shift;
  return sub {
    my $self = shift;
    # 为工作进程设置共享队列
    $self->{queue} = $queue;

    # 设置进程表文本并记录工作进程初始化
    prctl sprintf 'nd2: #%s %s: init', MCE->wid, lc($role);
    info sprintf 'applying role %s to worker %s', $role, MCE->wid;

    # 在 fork 后，将工作进程转换为相应的角色（管理器、调度器、轮询器等）
    Role::Tiny->apply_roles_to_object(
      $self => "App::Netdisco::Backend::Role::$role");

    # 如果工作进程有 worker_begin 方法，则调用它
    $self->worker_begin if $self->can('worker_begin');
    # 启动工作进程的主体逻辑
    $self->worker_body;
  };
}

=head1 NAME

netdisco-backend-fg - Job Control for Netdisco

=head1 SEE ALSO

=over 4

=item *

L<App::Netdisco>

=back

=cut
